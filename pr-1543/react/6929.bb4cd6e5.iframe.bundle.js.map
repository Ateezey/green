{"version":3,"file":"6929.bb4cd6e5.iframe.bundle.js","mappings":";AAwFA;AAAA;;;AAEA;;;ACiPA;;;;AACA;AAHA;AAAA;AAAA;AAAA;;;;;AAIA;AAJA;;;;;;AAKA;;AAFA;AADA;;;AAEA;;AAiCA;AADA;;;AAEA","sources":["webpack://green/./dist/libs/core/src/chunks/chunk.NLS2QZC7.js","webpack://green/./dist/libs/core/src/chunks/chunk.VMJYAH34.js"],"sourcesContent":["import {\n  TransitionalStyles\n} from \"./chunk.3XCSDEVC.js\";\nimport {\n  tokens\n} from \"./chunk.FCFC6KS2.js\";\nimport {\n  GdsElement\n} from \"./chunk.ZQ4D5K7J.js\";\nimport {\n  gdsCustomElement,\n  html\n} from \"./chunk.VOYMQ322.js\";\nimport {\n  __decorateClass\n} from \"./chunk.5VURDMKE.js\";\n\n// libs/core/src/components/segmented-control/segment/segment.ts\nimport { property } from \"lit/decorators.js\";\nimport { unsafeCSS } from \"lit\";\n\n// libs/core/src/components/segmented-control/segment/segment.style.css?inline\nvar segment_style_default = `:host {\n  display: flex;\n  transition: 0.2s;\n  z-index: 1;\n}\n\nbutton {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  background: transparent;\n  border-radius: calc(infinity * 1px);\n  border-width: 0;\n  color: var(--gds-sys-color-content-content);\n  cursor: pointer;\n  flex-grow: 1;\n  flex-shrink: 0;\n  font-family: inherit;\n  font-size: inherit;\n  overflow: hidden;\n  padding: 0 1rem;\n  text-align: center;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  width: 100%;\n\n  &:disabled {\n    cursor: not-allowed;\n    opacity: 0.5;\n  }\n}\n\n@media (pointer: fine) {\n  button:hover {\n    background-color: color-mix(\n      in srgb,\n      var(--gds-sys-color-state-layers-state-black-dim1),\n      transparent\n    );\n\n    &:disabled {\n      background-color: transparent;\n    }\n  }\n}\n\nbutton:focus-visible {\n  outline: 2px solid #000;\n  outline-offset: -2px;\n}\n`;\n\n// libs/core/src/components/segmented-control/segment/segment.ts\nvar GdsSegment = class extends GdsElement {\n  constructor() {\n    super(...arguments);\n    this.selected = false;\n    this.disabled = false;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    TransitionalStyles.instance.apply(this, \"gds-segmented\");\n    this.setAttribute(\"role\", \"listitem\");\n  }\n  render() {\n    return html`<button\n      aria-current=${String(this.selected)}\n      ?disabled=\"${this.disabled}\"\n    >\n      <slot></slot>\n    </button>`;\n  }\n};\nGdsSegment.styles = [...tokens, unsafeCSS(segment_style_default)];\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], GdsSegment.prototype, \"selected\", 2);\n__decorateClass([\n  property()\n], GdsSegment.prototype, \"value\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], GdsSegment.prototype, \"disabled\", 2);\nGdsSegment = __decorateClass([\n  gdsCustomElement(\"gds-segment\")\n], GdsSegment);\n\nexport {\n  GdsSegment\n};\n","import {\n  GdsSegment\n} from \"./chunk.NLS2QZC7.js\";\nimport {\n  resizeObserver\n} from \"./chunk.VHN4JEZC.js\";\nimport {\n  TransitionalStyles\n} from \"./chunk.3XCSDEVC.js\";\nimport {\n  tokens\n} from \"./chunk.FCFC6KS2.js\";\nimport {\n  watch\n} from \"./chunk.2WO4NHJ2.js\";\nimport {\n  GdsElement\n} from \"./chunk.ZQ4D5K7J.js\";\nimport {\n  gdsCustomElement,\n  html\n} from \"./chunk.VOYMQ322.js\";\nimport {\n  __decorateClass,\n  __privateAdd,\n  __privateGet,\n  __privateMethod,\n  __privateSet,\n  __privateWrapper\n} from \"./chunk.5VURDMKE.js\";\n\n// libs/core/src/components/segmented-control/segmented-control.ts\nimport { unsafeCSS } from \"lit\";\nimport { query, state, property } from \"lit/decorators.js\";\nimport { when } from \"lit/directives/when.js\";\nimport { msg } from \"@lit/localize\";\n\n// libs/core/src/components/segmented-control/segmented-control.style.css?inline\nvar segmented_control_style_default = `:host {\n  background-color: var(--gds-sys-color-container-container-dim1);\n  border: 0.25rem solid var(--gds-sys-color-container-container-dim1);\n  border-radius: calc(infinity * 1px);\n  box-sizing: border-box;\n  contain: layout;\n  display: inline-flex;\n  gap: 0.25rem;\n  height: 3rem;\n  max-width: 100%;\n  overflow: hidden;\n}\n\n:host([size='small']) {\n  height: 2.5rem;\n}\n\n#track {\n  box-sizing: border-box;\n  display: flex;\n  flex-grow: 0;\n  flex-shrink: 1;\n  overflow: hidden;\n  position: relative;\n  width: 100%;\n}\n\n#segments {\n  box-sizing: border-box;\n  display: inline-flex;\n  gap: 0.25rem;\n  position: relative;\n  transition: 0.2s;\n  z-index: 1;\n}\n\n#btn-prev,\n#btn-next {\n  align-items: center;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  aspect-ratio: 1;\n  background-color: var(--gds-sys-color-container-container-dim1);\n  border-radius: calc(infinity * 1px);\n  border-width: 0;\n  color: var(--gds-sys-color-content-content);\n  cursor: pointer;\n  display: flex;\n  font-size: 1rem;\n  height: 100%;\n  justify-content: center;\n  width: 2.5rem;\n\n  @media (pointer: fine) {\n    &:hover {\n      background-color: color-mix(\n        in srgb,\n        var(--gds-sys-color-state-layers-state-black-dim1),\n        var(--gds-sys-color-container-container-dim1)\n      );\n    }\n  }\n}\n\n:host([size='small']) #btn-prev,\n:host([size='small']) #btn-next {\n  width: 2rem;\n}\n\n::slotted(*) {\n  flex-grow: 1;\n  flex-shrink: 0;\n  z-index: 1;\n}\n\n#indicator {\n  background-color: var(--gds-sys-color-container-container-bright);\n  border-radius: calc(infinity * 1px);\n  height: 100%;\n  left: 0;\n  position: absolute;\n  transition:\n    transform 0.2s,\n    width 0.2s;\n  z-index: 0;\n}\n`;\n\n// libs/core/src/components/segmented-control/segmented-control.ts\nvar BTN_SIZE = {\n  small: 36,\n  medium: 44\n};\nvar getSegmentGap = (transitionalStyles) => transitionalStyles ? 0 : 4;\nvar _value, _firstVisibleIndex, _calculatedSegmentWidth, _segmentWidth, _segmentsContainerLeft, _focusedIndex, _dragStartX, _dragStartLeft, _isDragging, _startDrag, _drag, _endDrag, _calcVisibleAfterDrag, _calcLayout, _applySegmentsTransform, _handleSlotChange, handleSlotChange_fn, _scrollLeft, _scrollRight, _updateScrollBtnState, _updateIndicator, _handleSegmentClick, _updateSelectedFromValue;\nvar GdsSegmentedControl = class extends GdsElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _handleSlotChange);\n    this.segMinWidth = 100;\n    this.size = \"medium\";\n    __privateAdd(this, _value, void 0);\n    this._showPrevButton = false;\n    this._showNextButton = false;\n    __privateAdd(this, _firstVisibleIndex, 0);\n    __privateAdd(this, _calculatedSegmentWidth, 0);\n    __privateAdd(this, _segmentWidth, 0);\n    __privateAdd(this, _segmentsContainerLeft, 0);\n    __privateAdd(this, _focusedIndex, 0);\n    __privateAdd(this, _dragStartX, 0);\n    __privateAdd(this, _dragStartLeft, 0);\n    __privateAdd(this, _isDragging, false);\n    __privateAdd(this, _startDrag, (event) => {\n      __privateSet(this, _dragStartX, event.clientX);\n      __privateSet(this, _dragStartLeft, __privateGet(this, _segmentsContainerLeft));\n      __privateSet(this, _isDragging, true);\n    });\n    __privateAdd(this, _drag, (event) => {\n      if (!__privateGet(this, _isDragging))\n        return;\n      event.preventDefault();\n      const delta = event.clientX - __privateGet(this, _dragStartX);\n      if (Math.abs(delta) < 5)\n        return;\n      try {\n        if (!this._elSegments.hasPointerCapture(event.pointerId))\n          this._elSegments.setPointerCapture(event.pointerId);\n        __privateSet(this, _segmentsContainerLeft, __privateGet(this, _dragStartLeft) + delta);\n        __privateGet(this, _applySegmentsTransform).call(this);\n      } catch (e) {\n      }\n    });\n    __privateAdd(this, _endDrag, (event) => {\n      if (!__privateGet(this, _isDragging))\n        return;\n      __privateSet(this, _isDragging, false);\n      try {\n        this._elSegments.releasePointerCapture(event.pointerId);\n        __privateGet(this, _calcVisibleAfterDrag).call(this);\n      } catch (e) {\n      }\n    });\n    __privateAdd(this, _calcVisibleAfterDrag, () => {\n      __privateSet(this, _firstVisibleIndex, Math.round(\n        -__privateGet(this, _segmentsContainerLeft) / __privateGet(this, _calculatedSegmentWidth)\n      ));\n      __privateGet(this, _calcLayout).call(this);\n    });\n    // Calculates the layout based on the configured min width\n    // and the available space in the track\n    __privateAdd(this, _calcLayout, (followFocus = false) => {\n      const calcNumVisibleSegments = () => {\n        const numSegments = this.segments.length;\n        const availableWidth = this._elTrack.offsetWidth;\n        if (availableWidth / numSegments > this.segMinWidth) {\n          return {\n            count: numSegments,\n            segmentWidth: (availableWidth - getSegmentGap(this._isUsingTransitionalStyles) * (numSegments - 1)) / numSegments\n          };\n        }\n        const availableWidthIncBtns = this.offsetWidth - BTN_SIZE[this.size] * 2;\n        const maxVisibleSegments = Math.floor(\n          availableWidthIncBtns / this.segMinWidth\n        );\n        const segmentWidth = (availableWidth - getSegmentGap(this._isUsingTransitionalStyles) * (maxVisibleSegments - 1)) / maxVisibleSegments;\n        return {\n          count: maxVisibleSegments,\n          segmentWidth\n        };\n      };\n      const { count } = calcNumVisibleSegments();\n      if (followFocus) {\n        if (__privateGet(this, _focusedIndex) >= __privateGet(this, _firstVisibleIndex) + count) {\n          __privateSet(this, _firstVisibleIndex, __privateGet(this, _focusedIndex) - count + 1);\n        }\n        if (__privateGet(this, _focusedIndex) < __privateGet(this, _firstVisibleIndex)) {\n          __privateSet(this, _firstVisibleIndex, __privateGet(this, _focusedIndex));\n        }\n      }\n      const endFirstIndex = this.segments.length - count;\n      const hasReachedEnd = __privateGet(this, _firstVisibleIndex) >= endFirstIndex;\n      const isAtStart = __privateGet(this, _firstVisibleIndex) <= 0;\n      if (hasReachedEnd) {\n        __privateSet(this, _firstVisibleIndex, endFirstIndex);\n      }\n      if (isAtStart) {\n        __privateSet(this, _firstVisibleIndex, 0);\n      }\n      __privateGet(this, _updateScrollBtnState).call(this, count);\n      this.updateComplete.then(() => {\n        const { segmentWidth, count: count2 } = calcNumVisibleSegments();\n        this.segments.forEach((segment) => {\n          segment.style.width = segmentWidth + \"px\";\n        });\n        __privateSet(this, _segmentsContainerLeft, -__privateGet(this, _firstVisibleIndex) * segmentWidth - getSegmentGap(this._isUsingTransitionalStyles) * __privateGet(this, _firstVisibleIndex));\n        __privateGet(this, _applySegmentsTransform).call(this);\n        __privateSet(this, _calculatedSegmentWidth, segmentWidth);\n        __privateSet(this, _segmentWidth, segmentWidth);\n        __privateGet(this, _updateIndicator).call(this);\n      });\n    });\n    __privateAdd(this, _applySegmentsTransform, () => {\n      window.requestAnimationFrame(() => {\n        this._elSegments.style.transform = `translateX(${__privateGet(this, _segmentsContainerLeft)}px)`;\n      });\n    });\n    __privateAdd(this, _scrollLeft, () => {\n      __privateWrapper(this, _firstVisibleIndex)._--;\n      __privateGet(this, _calcLayout).call(this);\n    });\n    __privateAdd(this, _scrollRight, () => {\n      __privateWrapper(this, _firstVisibleIndex)._++;\n      __privateGet(this, _calcLayout).call(this);\n    });\n    // Updates the visibility of the scroll buttons\n    __privateAdd(this, _updateScrollBtnState, (numVisibleSegments) => {\n      this._showPrevButton = __privateGet(this, _firstVisibleIndex) > 0;\n      this._showNextButton = __privateGet(this, _firstVisibleIndex) < this.segments.length - numVisibleSegments;\n    });\n    // Updates the selection indicator position\n    __privateAdd(this, _updateIndicator, () => {\n      const segment = this.segments.find((s) => s.selected);\n      if (segment) {\n        const selectedSegmentIndex = this.segments.indexOf(segment);\n        const offset = selectedSegmentIndex * __privateGet(this, _segmentWidth) + getSegmentGap(this._isUsingTransitionalStyles) * selectedSegmentIndex;\n        this._elIndicator.style.transform = `translateX(${offset}px)`;\n        this._elIndicator.style.width = `${__privateGet(this, _segmentWidth)}px`;\n      } else {\n        this._elIndicator.style.transform = `translateX(-100%)`;\n        this._elIndicator.style.width = `0px`;\n      }\n    });\n    __privateAdd(this, _handleSegmentClick, (event) => {\n      const selectedSegment = this.segments.find(\n        (s) => s === event.target || s.contains(event.target)\n      );\n      if (selectedSegment) {\n        this.segments.forEach((s) => s.selected = false);\n        selectedSegment.selected = true;\n        __privateSet(this, _value, selectedSegment.value);\n        __privateGet(this, _updateIndicator).call(this);\n        this.dispatchEvent(\n          new CustomEvent(\"change\", {\n            detail: { segment: selectedSegment },\n            bubbles: true,\n            composed: true\n          })\n        );\n      }\n    });\n    __privateAdd(this, _updateSelectedFromValue, () => {\n      if (!__privateGet(this, _value))\n        return;\n      this.updateComplete.then(() => {\n        const selectedSegment = this.segments.find((s) => s.value === __privateGet(this, _value));\n        if (selectedSegment) {\n          this.segments.forEach((s) => s.selected = false);\n          selectedSegment.selected = true;\n          __privateSet(this, _focusedIndex, this.segments.indexOf(selectedSegment));\n          __privateGet(this, _calcLayout).call(this, true);\n        }\n      });\n    });\n  }\n  get value() {\n    return __privateGet(this, _value);\n  }\n  set value(val) {\n    __privateSet(this, _value, val);\n    __privateGet(this, _updateSelectedFromValue).call(this);\n  }\n  /**\n   * Returns the segments in the control\n   * @readonly\n   */\n  get segments() {\n    return this._elSlot ? this._elSlot.assignedElements() : [];\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    TransitionalStyles.instance.apply(this, \"gds-segmented-control\");\n    this.addEventListener(\"focusin\", (e) => {\n      if (e.target instanceof GdsSegment) {\n        __privateSet(this, _focusedIndex, this.segments.indexOf(e.target));\n        __privateGet(this, _calcLayout).call(this, true);\n      }\n    });\n  }\n  render() {\n    return html`${when(\n      this._showPrevButton,\n      () => html`<button\n            id=\"btn-prev\"\n            @click=${__privateGet(this, _scrollLeft)}\n            aria-label=${msg(\"Scroll right\")}\n          >\n            <gds-icon-chevron-left />\n          </button>`\n    )}\n      <div\n        id=\"track\"\n        @scroll=${() => {\n      this._elTrack.scrollLeft = 0;\n    }}\n      >\n        <div\n          id=\"segments\"\n          @pointerdown=${__privateGet(this, _startDrag)}\n          @pointermove=${__privateGet(this, _drag)}\n          @touchmove=${__privateGet(this, _drag)}\n          @pointerup=${__privateGet(this, _endDrag)}\n          @pointercancel=${__privateGet(this, _endDrag)}\n          role=\"list\"\n        >\n          <slot\n            gds-allow=\"gds-segment\"\n            @click=${__privateGet(this, _handleSegmentClick)}\n            @slotchange=${__privateMethod(this, _handleSlotChange, handleSlotChange_fn)}\n            role=\"none\"\n          ></slot>\n          <div id=\"indicator\" role=\"none\"></div>\n        </div>\n      </div>\n      ${when(\n      this._showNextButton,\n      () => html`<button\n            id=\"btn-next\"\n            @click=${__privateGet(this, _scrollRight)}\n            aria-label=${msg(\"Scroll right\")}\n          >\n            <gds-icon-chevron-right />\n          </button>`\n    )}`;\n  }\n  _recalculateMinWidth() {\n    this.updateComplete.then(() => __privateGet(this, _calcLayout).call(this));\n  }\n};\n_value = new WeakMap();\n_firstVisibleIndex = new WeakMap();\n_calculatedSegmentWidth = new WeakMap();\n_segmentWidth = new WeakMap();\n_segmentsContainerLeft = new WeakMap();\n_focusedIndex = new WeakMap();\n_dragStartX = new WeakMap();\n_dragStartLeft = new WeakMap();\n_isDragging = new WeakMap();\n_startDrag = new WeakMap();\n_drag = new WeakMap();\n_endDrag = new WeakMap();\n_calcVisibleAfterDrag = new WeakMap();\n_calcLayout = new WeakMap();\n_applySegmentsTransform = new WeakMap();\n_handleSlotChange = new WeakSet();\nhandleSlotChange_fn = function() {\n  var _a;\n  const selSegmentValue = (_a = this.segments.find((s) => s.selected)) == null ? void 0 : _a.value;\n  if (selSegmentValue) {\n    __privateSet(this, _value, selSegmentValue);\n  }\n  __privateGet(this, _calcLayout).call(this);\n};\n_scrollLeft = new WeakMap();\n_scrollRight = new WeakMap();\n_updateScrollBtnState = new WeakMap();\n_updateIndicator = new WeakMap();\n_handleSegmentClick = new WeakMap();\n_updateSelectedFromValue = new WeakMap();\nGdsSegmentedControl.styles = [tokens, unsafeCSS(segmented_control_style_default)];\n__decorateClass([\n  property({ type: Number, attribute: \"seg-min-width\" })\n], GdsSegmentedControl.prototype, \"segMinWidth\", 2);\n__decorateClass([\n  property({ reflect: true })\n], GdsSegmentedControl.prototype, \"size\", 2);\n__decorateClass([\n  property()\n], GdsSegmentedControl.prototype, \"value\", 1);\n__decorateClass([\n  query(\"slot\")\n], GdsSegmentedControl.prototype, \"_elSlot\", 2);\n__decorateClass([\n  query(\"#indicator\")\n], GdsSegmentedControl.prototype, \"_elIndicator\", 2);\n__decorateClass([\n  query(\"#track\")\n], GdsSegmentedControl.prototype, \"_elTrack\", 2);\n__decorateClass([\n  query(\"#segments\")\n], GdsSegmentedControl.prototype, \"_elSegments\", 2);\n__decorateClass([\n  state()\n], GdsSegmentedControl.prototype, \"_showPrevButton\", 2);\n__decorateClass([\n  state()\n], GdsSegmentedControl.prototype, \"_showNextButton\", 2);\n__decorateClass([\n  resizeObserver(),\n  watch(\"segMinWidth\")\n], GdsSegmentedControl.prototype, \"_recalculateMinWidth\", 1);\nGdsSegmentedControl = __decorateClass([\n  gdsCustomElement(\"gds-segmented-control\")\n], GdsSegmentedControl);\n\nexport {\n  GdsSegmentedControl\n};\n"],"names":[],"sourceRoot":""}