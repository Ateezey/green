{"version":3,"file":"7808.d6d675d3.iframe.bundle.js","mappings":";;;;AA8PA;AAHA;;;;;AAIA;;AADA;AADA;;;AAEA;;AAkBA;AADA;;;AAEA;ACjLA;AAAA;;;AAEA","sources":["webpack://green/./dist/libs/core/src/chunks/chunk.AQZEG63U.js","webpack://green/./dist/libs/core/src/chunks/chunk.WI2GLZDM.js"],"sourcesContent":["import {\n  resizeObserver\n} from \"./chunk.VHN4JEZC.js\";\nimport {\n  TransitionalStyles\n} from \"./chunk.QMR62KBI.js\";\nimport {\n  watch\n} from \"./chunk.TYGMNHNO.js\";\nimport {\n  tokens\n} from \"./chunk.JCLQ6R4U.js\";\nimport {\n  GdsElement\n} from \"./chunk.OULFUNDF.js\";\nimport {\n  gdsCustomElement,\n  html\n} from \"./chunk.VOYMQ322.js\";\nimport {\n  __decorateClass,\n  __privateAdd,\n  __privateGet,\n  __privateMethod,\n  __privateSet\n} from \"./chunk.SEHSDSX2.js\";\n\n// libs/core/src/components/segmented-control/segmented-control.ts\nimport { unsafeCSS } from \"lit\";\nimport { query, state, property } from \"lit/decorators.js\";\nimport { when } from \"lit/directives/when.js\";\nimport { msg } from \"@lit/localize\";\n\n// libs/core/src/components/segmented-control/segmented-control.style.css?inline\nvar segmented_control_style_default = `:host {\n  background-color: var(--gds-sys-color-container-container-dim1);\n  border: 0.25rem solid var(--gds-sys-color-container-container-dim1);\n  border-radius: calc(infinity * 1px);\n  box-sizing: border-box;\n  contain: layout;\n  display: inline-flex;\n  gap: 0.25rem;\n  height: 3rem;\n  max-width: 100%;\n  overflow: hidden;\n}\n\n:host([size='small']) {\n  height: 2.5rem;\n}\n\n#track {\n  box-sizing: border-box;\n  display: flex;\n  flex-grow: 1;\n  scroll-snap-type: inline mandatory;\n  overscroll-behavior-x: contain;\n  scroll-behavior: smooth;\n  overflow: hidden;\n  position: relative;\n  gap: 0.25rem;\n  box-sizing: border-box;\n  position: relative;\n}\n\n#btn-prev,\n#btn-next {\n  align-items: center;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  aspect-ratio: 1;\n  background-color: var(--gds-sys-color-container-container-dim1);\n  border-radius: calc(infinity * 1px);\n  border-width: 0;\n  color: var(--gds-sys-color-content-content);\n  cursor: pointer;\n  display: flex;\n  font-size: 1rem;\n  height: 100%;\n  justify-content: center;\n  width: 2.5rem;\n\n  @media (pointer: fine) {\n    &:hover {\n      background-color: color-mix(\n        in srgb,\n        var(--gds-sys-color-state-layers-state-black-dim1),\n        var(--gds-sys-color-container-container-dim1)\n      );\n    }\n  }\n}\n\n:host([size='small']) #btn-prev,\n:host([size='small']) #btn-next {\n  width: 2rem;\n}\n\n::slotted(*) {\n  flex-grow: 1;\n  flex-shrink: 0;\n  z-index: 1;\n  scroll-snap-align: start;\n}\n\n#indicator {\n  background-color: var(--gds-sys-color-container-container-bright);\n  border-radius: calc(infinity * 1px);\n  height: 100%;\n  left: 0;\n  position: absolute;\n  transition:\n    transform 0.2s,\n    width 0.2s;\n  z-index: 0;\n}\n`;\n\n// libs/core/src/components/segmented-control/segmented-control.ts\nvar BTN_SIZE = {\n  small: 36,\n  medium: 44\n};\nvar getSegmentGap = (transitionalStyles) => transitionalStyles ? 0 : 4;\nvar _value, _segmentWidth, _calcLayout, _handleSlotChange, handleSlotChange_fn, _scrollLeft, _scrollRight, _updateScrollBtnState, _updateIndicator, _handleSegmentClick, _updateSelectedFromValue;\nvar GdsSegmentedControl = class extends GdsElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _handleSlotChange);\n    this.segMinWidth = 100;\n    this.size = \"medium\";\n    __privateAdd(this, _value, void 0);\n    this._showPrevButton = false;\n    this._showNextButton = false;\n    __privateAdd(this, _segmentWidth, 0);\n    this.intersectionObserver = null;\n    // Calculates the layout based on the configured min width\n    // and the available space in the track\n    __privateAdd(this, _calcLayout, (followFocus = false) => {\n      console.log(\"calcLayout\");\n      const calcNumVisibleSegments = () => {\n        const numSegments = this.segments.length;\n        const availableWidth = this._elTrack.offsetWidth;\n        if (availableWidth / numSegments > this.segMinWidth) {\n          return {\n            count: numSegments,\n            segmentWidth: (availableWidth - getSegmentGap(this._isUsingTransitionalStyles) * (numSegments - 1)) / numSegments\n          };\n        }\n        const availableWidthIncBtns = this.offsetWidth - BTN_SIZE[this.size] * 2;\n        const maxVisibleSegments = Math.floor(\n          availableWidthIncBtns / this.segMinWidth\n        );\n        const segmentWidth = (availableWidth - getSegmentGap(this._isUsingTransitionalStyles) * (maxVisibleSegments - 1)) / maxVisibleSegments;\n        return {\n          count: maxVisibleSegments,\n          segmentWidth\n        };\n      };\n      __privateGet(this, _updateScrollBtnState).call(this);\n      this.updateComplete.then(() => {\n        const { segmentWidth } = calcNumVisibleSegments();\n        this.segments.forEach((segment) => {\n          segment.style.width = segmentWidth + \"px\";\n        });\n        __privateSet(this, _segmentWidth, segmentWidth);\n        __privateGet(this, _updateIndicator).call(this);\n      });\n    });\n    __privateAdd(this, _scrollLeft, () => {\n      this.segments.filter((s, i, arr) => {\n        var _a;\n        return ((_a = arr[i + 1]) == null ? void 0 : _a.isVisible) && !s.isVisible;\n      })[0].scrollIntoView();\n    });\n    __privateAdd(this, _scrollRight, () => {\n      this.segments.filter((s, i, arr) => {\n        var _a;\n        return ((_a = arr[i - 1]) == null ? void 0 : _a.isVisible) && !s.isVisible;\n      }).reverse()[0].scrollIntoView({ block: \"end\" });\n    });\n    // Updates the visibility of the scroll buttons\n    __privateAdd(this, _updateScrollBtnState, () => {\n      this._showPrevButton = !this.segments[0].isVisible;\n      this._showNextButton = !this.segments[this.segments.length - 1].isVisible;\n    });\n    // Updates the selection indicator position\n    __privateAdd(this, _updateIndicator, () => {\n      const segment = this.segments.find((s) => s.selected);\n      if (segment) {\n        const selectedSegmentIndex = this.segments.indexOf(segment);\n        const offset = selectedSegmentIndex * __privateGet(this, _segmentWidth) + getSegmentGap(this._isUsingTransitionalStyles) * selectedSegmentIndex;\n        this._elIndicator.style.transform = `translateX(${offset}px)`;\n        this._elIndicator.style.width = `${__privateGet(this, _segmentWidth)}px`;\n      } else {\n        this._elIndicator.style.transform = `translateX(-100%)`;\n        this._elIndicator.style.width = `0px`;\n      }\n    });\n    __privateAdd(this, _handleSegmentClick, (event) => {\n      const selectedSegment = this.segments.find(\n        (s) => s === event.target || s.contains(event.target)\n      );\n      if (selectedSegment) {\n        this.segments.forEach((s) => s.selected = false);\n        selectedSegment.selected = true;\n        __privateSet(this, _value, selectedSegment.value);\n        __privateGet(this, _updateIndicator).call(this);\n        this.dispatchEvent(\n          new CustomEvent(\"change\", {\n            detail: { segment: selectedSegment },\n            bubbles: true,\n            composed: true\n          })\n        );\n      }\n    });\n    __privateAdd(this, _updateSelectedFromValue, () => {\n      if (!__privateGet(this, _value))\n        return;\n      this.updateComplete.then(() => {\n        const selectedSegment = this.segments.find((s) => s.value === __privateGet(this, _value));\n        if (selectedSegment) {\n          this.segments.forEach((s) => s.selected = false);\n          selectedSegment.selected = true;\n          __privateGet(this, _calcLayout).call(this, true);\n        }\n      });\n    });\n  }\n  get value() {\n    return __privateGet(this, _value);\n  }\n  set value(val) {\n    __privateSet(this, _value, val);\n    __privateGet(this, _updateSelectedFromValue).call(this);\n  }\n  /**\n   * Returns the segments in the control\n   * @readonly\n   */\n  get segments() {\n    return this._elSlot ? this._elSlot.assignedElements() : [];\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    TransitionalStyles.instance.apply(this, \"gds-segmented-control\");\n  }\n  render() {\n    return html`${when(\n      this._showPrevButton,\n      () => html`<button\n            id=\"btn-prev\"\n            @click=${__privateGet(this, _scrollLeft)}\n            aria-label=${msg(\"Scroll right\")}\n          >\n            <gds-icon-chevron-left />\n          </button>`\n    )}\n      <div id=\"track\" role=\"list\">\n        <slot\n          gds-allow=\"gds-segment\"\n          @click=${__privateGet(this, _handleSegmentClick)}\n          @slotchange=${__privateMethod(this, _handleSlotChange, handleSlotChange_fn)}\n          role=\"none\"\n        ></slot>\n        <div id=\"indicator\" role=\"none\"></div>\n      </div>\n      ${when(\n      this._showNextButton,\n      () => html`<button\n            id=\"btn-next\"\n            @click=${__privateGet(this, _scrollRight)}\n            aria-label=${msg(\"Scroll right\")}\n          >\n            <gds-icon-chevron-right />\n          </button>`\n    )}`;\n  }\n  _recalculateMinWidth() {\n    this.updateComplete.then(() => __privateGet(this, _calcLayout).call(this));\n  }\n};\n_value = new WeakMap();\n_segmentWidth = new WeakMap();\n_calcLayout = new WeakMap();\n_handleSlotChange = new WeakSet();\nhandleSlotChange_fn = function() {\n  var _a, _b;\n  const selSegmentValue = (_a = this.segments.find((s) => s.selected)) == null ? void 0 : _a.value;\n  if (selSegmentValue) {\n    __privateSet(this, _value, selSegmentValue);\n  }\n  (_b = this.intersectionObserver) == null ? void 0 : _b.disconnect();\n  this.intersectionObserver = new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        const segment = entry.target;\n        segment._isVisible = entry.isIntersecting;\n      });\n      __privateGet(this, _updateScrollBtnState).call(this);\n      __privateGet(this, _calcLayout).call(this);\n    },\n    {\n      root: this._elTrack,\n      rootMargin: \"0px\",\n      threshold: 0.1\n    }\n  );\n  this.segments.forEach((s) => {\n    var _a2;\n    (_a2 = this.intersectionObserver) == null ? void 0 : _a2.observe(s);\n  });\n};\n_scrollLeft = new WeakMap();\n_scrollRight = new WeakMap();\n_updateScrollBtnState = new WeakMap();\n_updateIndicator = new WeakMap();\n_handleSegmentClick = new WeakMap();\n_updateSelectedFromValue = new WeakMap();\nGdsSegmentedControl.styles = [tokens, unsafeCSS(segmented_control_style_default)];\n__decorateClass([\n  property({ type: Number, attribute: \"seg-min-width\" })\n], GdsSegmentedControl.prototype, \"segMinWidth\", 2);\n__decorateClass([\n  property({ reflect: true })\n], GdsSegmentedControl.prototype, \"size\", 2);\n__decorateClass([\n  property()\n], GdsSegmentedControl.prototype, \"value\", 1);\n__decorateClass([\n  query(\"slot\")\n], GdsSegmentedControl.prototype, \"_elSlot\", 2);\n__decorateClass([\n  query(\"#indicator\")\n], GdsSegmentedControl.prototype, \"_elIndicator\", 2);\n__decorateClass([\n  query(\"#track\")\n], GdsSegmentedControl.prototype, \"_elTrack\", 2);\n__decorateClass([\n  state()\n], GdsSegmentedControl.prototype, \"_showPrevButton\", 2);\n__decorateClass([\n  state()\n], GdsSegmentedControl.prototype, \"_showNextButton\", 2);\n__decorateClass([\n  resizeObserver(),\n  watch(\"segMinWidth\")\n], GdsSegmentedControl.prototype, \"_recalculateMinWidth\", 1);\nGdsSegmentedControl = __decorateClass([\n  gdsCustomElement(\"gds-segmented-control\")\n], GdsSegmentedControl);\n\nexport {\n  GdsSegmentedControl\n};\n","import {\n  TransitionalStyles\n} from \"./chunk.QMR62KBI.js\";\nimport {\n  tokens\n} from \"./chunk.JCLQ6R4U.js\";\nimport {\n  GdsElement\n} from \"./chunk.OULFUNDF.js\";\nimport {\n  gdsCustomElement,\n  html\n} from \"./chunk.VOYMQ322.js\";\nimport {\n  __decorateClass\n} from \"./chunk.SEHSDSX2.js\";\n\n// libs/core/src/components/segmented-control/segment/segment.ts\nimport { property } from \"lit/decorators.js\";\nimport { unsafeCSS } from \"lit\";\n\n// libs/core/src/components/segmented-control/segment/segment.style.css?inline\nvar segment_style_default = `:host {\n  display: flex;\n  transition: 0.2s;\n  z-index: 1;\n}\n\nbutton {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  background: transparent;\n  border-radius: calc(infinity * 1px);\n  border-width: 0;\n  color: var(--gds-sys-color-content-content);\n  cursor: pointer;\n  flex-grow: 1;\n  flex-shrink: 0;\n  font-family: inherit;\n  font-size: inherit;\n  overflow: hidden;\n  padding: 0 1rem;\n  text-align: center;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  width: 100%;\n\n  &:disabled {\n    cursor: not-allowed;\n    opacity: 0.5;\n  }\n}\n\n@media (pointer: fine) {\n  button:hover {\n    background-color: color-mix(\n      in srgb,\n      var(--gds-sys-color-state-layers-state-black-dim1),\n      transparent\n    );\n\n    &:disabled {\n      background-color: transparent;\n    }\n  }\n}\n\nbutton:focus-visible {\n  outline: 2px solid #000;\n  outline-offset: -2px;\n}\n`;\n\n// libs/core/src/components/segmented-control/segment/segment.ts\nvar GdsSegment = class extends GdsElement {\n  constructor() {\n    super(...arguments);\n    this.selected = false;\n    this.disabled = false;\n    // This is deliberatly not marked as private, since we're setting it from the parent component,\n    // but it is not meant to be set by the consumer.\n    this._isVisible = true;\n  }\n  /**\n   * Whether the segment is currently visible.\n   */\n  get isVisible() {\n    return this._isVisible;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    TransitionalStyles.instance.apply(this, \"gds-segmented\");\n    this.setAttribute(\"role\", \"listitem\");\n  }\n  render() {\n    return html`<button\n      aria-current=${String(this.selected)}\n      ?disabled=\"${this.disabled}\"\n    >\n      <slot></slot>\n    </button>`;\n  }\n};\nGdsSegment.styles = [...tokens, unsafeCSS(segment_style_default)];\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], GdsSegment.prototype, \"selected\", 2);\n__decorateClass([\n  property()\n], GdsSegment.prototype, \"value\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], GdsSegment.prototype, \"disabled\", 2);\nGdsSegment = __decorateClass([\n  gdsCustomElement(\"gds-segment\")\n], GdsSegment);\n\nexport {\n  GdsSegment\n};\n"],"names":[],"sourceRoot":""}